/*******************************************************************************
 * Л А Б О Р А Т О Р Н А Я   Р А Б О Т А  №2  З А   2   С Е М Е С Т Р   С  +  +*
 *-----------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                   *
 * Project Name  : Двумерные массивы                                           *
 * File Name     : Вариант1.CPP                                                *
 * Programmer(s) : Викулов Д.Г.                                                *
 * Modifyed By   :                                                             *
 * Created       : 1/04/22                                                     *
 * Last Revision : 17/04/22                                                    *
 * Comment(s)    : Получает на вход из файла параметры массива и его           *
 *                 составляющие. Сначала ищет количество строк, не содержащих  *
 *                 ни одного чётного элемента. Затем определяет максимальное   *
 *                 из чисел, встречающихся в матрице более одного раза.        *
 *******************************************************************************/

#include <iostream>    // стандартные потоки ввода/вывода
#include <fstream>     // файловые потоки ввода/вывода
using namespace std;   // используем пространство имён std

/***************************************************************/
/*          Г Л О Б А Л Ь Н Ы Е   К О Н С Т А Н Т Ы            */
/***************************************************************/
const int N_Max = 10;                    // неизменяемое максимальное количество строк матрицы                                  
const int M_Max = 10;                    // неизменяемое максимальное количество столбцов матрицы

/*******************************************************************/
/*                    Н А Б О Р    Т Е С Т О В                     */
/*******************************************************************/
//ДЛЯ МАТРИЦЫ А
//const char* FNAME = "Faila_net.txt";      //путь к файлу через константный указатель
//const char* FNAME = "Pustota.txt";
//const char* FNAME = "rN_ne_chislo.txt";
//const char* FNAME = "rN_Less_0.txt";
//const char* FNAME = "rM_ne_chislo.txt";
//const char* FNAME = "rM_Less_0.txt";
//const char* FNAME = "V_Massive_Ne_Chislo.txt";
//const char* FNAME = "Chislo_elementov_bigger_objavlennogo.txt";
//const char* FNAME = "Chislo_elementov_less_objavlennogo.txt";
//const char* FNAME = "Vse_po_odnomy.txt";
//const char* FNAME = "V_Massive_Vse_Stroki_Chet.txt";
const char* FNAME = "Vse_Verno.txt";
//const char* FNAME = "A.txt";


//ДЛЯ МАТРИЦЫ B

//const char* FNAMEB = "Faila_netB.txt";      //путь к файлу через константный указатель
//const char* FNAMEB = "PustotaB.txt";
//const char* FNAMEB = "rN_ne_chisloB.txt";
//const char* FNAMEB = "rN_Less_0B.txt";
//const char* FNAMEB = "rM_ne_chisloB.txt";
//const char* FNAMEB = "rM_Less_0B.txt";
//const char* FNAMEB = "V_Massive_Ne_ChisloB.txt";
//const char* FNAMEB = "Chislo_elementov_bigger_objavlennogoB.txt";
//const char* FNAMEB = "Chislo_elementov_less_objavlennogoB.txt";
//const char* FNAMEB = "Vse_po_odnomyB.txt";
//const char* FNAMEB = "V_Massive_Vse_Stroki_ChetB.txt";
const char* FNAMEB = "Vse_VernoB.txt";

/***************************************************************/
/*          П Р О Т О Т И П Ы    Ф У Н К Ц И Й                 */
/***************************************************************/
// сообщения об ошибках
void PrintMessage(int xErrCode                 // код ошибки
                , const char* FName);          // имя файла с ошибкой



// чтение из файла
void reading_matr(int pmatr[][M_Max]           // указатель на массив
                , int* rN                      // реальное количество строк
                , int* rM                      // реальное количесвто столбцов
                , int& ErrNo                   // номер ошибки
                , const char* FNAME);          // имя файла

//печать матрицы из фала
void print_matr(int pmatr[][M_Max]             // указатель на массив
              , int rN                         // реальное количество строк
              , int rM);                       // реальное количество столбцов


// поиск строк, не содержащих ни одного чётного
int kol_vo(int pmatr[][M_Max]                  // указатель на массив
         , int rN                              // реальное количество строк
         , int rM                              // реальное количество столбцов
         , int & ErrNo);                       // номер ошибки


// поиск максимального из чисел, встречающихся более одного раза
int maxim(int pmatr[][M_Max]                   // указатель на массив
        , int rN                               // реальное количество строк
        , int rM                               // реальное количество столбцов
        , int & ErrNo);                        // код ошибки            

// сортировка вектора-массива по возрастанию
int sort(int* vector                           // указатель на вектор-массив
       , int mvlen);                           // длина вектора-массива

/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/

int main()
{
    system("color F0");                        // делаем консоль светлой
    setlocale(LC_ALL, "Rus");                  // подключаем русский язык
    system("cls");                             // чистим консоль перед выводом
 
    int rN = 0;                                // реальное количество строк
    int rM = 0;                                // реальное количество столбцов
    int ErrNo = 0;                             // код ошибки
    int matrA[N_Max][M_Max] = {0};             // матрица A из элементов в файле
    int matrB[N_Max][M_Max] = {0};             // матрица B из элементов в файле
    


    //вызов функции с ФАКТИЧЕСКИМИ параметрами
    reading_matr(matrA, &rN, &rM, ErrNo, FNAME);   // т.к в прототипе указатели, то передаём адреса
    print_matr(matrA, rN, rM);                     // выводим считанную матрицу

    if (ErrNo == 0)                                // ошибок нет
    {
        int stroki = kol_vo(matrA, rN, rM, ErrNo); // переменная, отвечающая за количество строк с нечётными элементами. Передаём значения rN и rM, т.к не надо их менять
        cout << "Количество строк, не содержащих ни одного чётного элемента: " << stroki << endl;
        int maximum = maxim(matrA, rN, rM, ErrNo);        // переменная, отвечающая за максимальное число, встречающееся более одного раза. /........./
    }
    else
    {
        PrintMessage(ErrNo, FNAME);                // печатаем сведения об ошибке
    } 
    if (ErrNo == 7 || ErrNo == 10)
    {
        PrintMessage(ErrNo, FNAME);                // печатаем сведения об ошибке
    }



    ErrNo = 0;
    //для матрицы B
    cout << "\n\n\t\t\t РАБОТАЕМ С МАТРИЦЕЙ B: \n";
    reading_matr(matrB, &rN, &rM, ErrNo, FNAMEB);  // т.к в прототипе указатели, то передаём адреса
    print_matr(matrB, rN, rM);                     // выводим считанную матрицу

    if (ErrNo == 0)                                // ошибок нет
    {
        int stroki = kol_vo(matrB, rN, rM, ErrNo); // переменная, отвечающая за количество строк с нечётными элементами. Передаём значения rN и rM, т.к не надо их менять
        cout << "Количество строк, не содержащих ни одного чётного элемента: " << stroki << endl;
        int maximum = maxim(matrB, rN, rM, ErrNo);        // переменная, отвечающая за максимальное число, встречающееся более одного раза. /........./
    }
    else
    {
        PrintMessage(ErrNo, FNAMEB);                // печатаем сведения об ошибке
    }
    if (ErrNo == 7 || ErrNo == 10)
    {
        PrintMessage(ErrNo, FNAMEB);                // печатаем сведения об ошибке
    }

    system("PAUSE");
    return (0);
} // main

 /***************************************************/
 /*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
 /***************************************************/
 /*-------------------------------------------------*/
 /* чтение строк из файла */
 /*-----------------------*/
void reading_matr(int pmatr[][M_Max]  // указатель на массив
                , int *rN             // реальное количество строк
                , int *rM             // реальное количество столбцов
                , int &ErrNo          // код ошибки
                , const char*FNAME)   // имя файла 
{
    int CountLine = 0;                // счётчик по строкам
    int CountColumn = 0;              // счётчик по столбцам
    int i = 0;                        // счётчик
    ifstream fin;                     // объявление объекта для потокового введения данных из файла
    fin.open(FNAME);                  // связываем обЪект с файлом. Открываем для чтения

    if (!fin.is_open())               //файл не найден
    {
        ErrNo = 1;
        fin.close();                  // закрыть файл
        return ;                      // возвращаем значение, соответствующее типу
    }// if

    if (fin.peek() == EOF)            // файл пуст
    {
        ErrNo = 2;
        fin.close();                  // закрыть файл
        return ;                      // возвращаем значение, соответствующее типу
    }// if
   
    fin >>  *rN;                       // считываем количество строк (число *rN, а не указатель rN)
    fin >> *rM;                       // считываем количество столбцов (число *rM, а не указатель rM)

    if (fin.fail())                   // в файле не число (прочитали две первых строки - заметили несоответствие типов)
    {
        ErrNo = 3;
        fin.close();                  // закрыть файл
        return;                       // возвращаем значение, соответствующее типу
    }// if

    cout << "Исходные данные матрицы: \n";
    cout << "Количество строк: "    << *rN << endl;
    cout << "Количество столбцов: " << *rM << endl;

    if (*rN<0)                        // значение указателя отрицательно
    {
        
        ErrNo = 8;
        fin.close();                 // закрыть файл
        return;                      // возвращаем значение, соответствующее типу
    }// if
     
    if (*rM < 0)                     // значение указателя отрицательно
    {
        ErrNo = 9;
        fin.close();                 // закрыть файл
        return;                      // возвращаем значение, соответствующее типу
    }// if

    while (!fin.eof())               // пока не дошли до коца файла
    {
        fin >> pmatr[CountLine][CountColumn]; // считали элемент, поместили его на место pmatr[CountLine][CountColumn]
        CountColumn = CountColumn + 1;        // перешли к следующему столбцу

        if (CountColumn == *rM)               // если достигли конца строки
        {
            CountLine = CountLine + 1;        // переходим к другой строке
            CountColumn = 0;                  // становимся на начало строки
        }//if   
        if (i > (*rN * *rM))                     // реальное количество больше объявленного
        {
            //вызов функции с ФАКТИЧЕСКИМИ параметрами
            ErrNo = 5;
            fin.close();                         // закрыть файл
            return;                             // возвращаем значение, соответствующее типу
        }// if
        if (fin.fail())                       // проверка на нечисло в самом массиве (на соответствие типов данных)
        {
            ErrNo = 4;
            fin.close();                      // закрыть файл
            return ;                          // возвращаем значение, соответствующее типу
        }// if

        i = i + 1;                            // увеличили счётчик
    }// while



    if (i < (*rN * *rM))                     // реальное количество меньше объявленного
    {
        //вызов функции с ФАКТИЧЕСКИМИ параметрами
        ErrNo = 6;
        fin.close();                         // закрыть файл
        return;                              // возвращаем значение, соответствующее типу
    }// if
    fin.close();                             // закрыть файл
    return ;                                 // возвращаем значение, соответствующее типу, если всё хорошо
}// reading_matr


/*-------------------------------------------------*/
 /*  печать          */
 /* считанной матрицы*/
 /*------------------------*/
void print_matr(int pmatr[][M_Max]          // указатель на массив
              , int rN                      // реальное количество строк
              , int rM)                     // реальное количество столбцов
{
    int i = 0;                              // счётчики                 
    int j = 0;
    for (i = 0; i < rN; i++)                // пока не дошли до последней строки
    {
        for (j = 0; j < rM; j++)            // пока не дошли до последнего столбца
        {
            cout << pmatr[i][j] << ' ';     // выведем полученную матрицу
        }// for
        cout << endl;
    }// for
    cout << endl;
}//print_matr

 /*-------------------------------------------------*/
 /*  количество строк      */
 /* с нечётными элементами */
 /*------------------------*/
int kol_vo(int pmatr[][M_Max]               // указатель на массив
         , int rN                           // фактическое значение реального количества строк
         , int rM                           // фактическое значение реального количества столбцов
         , int &ErrNo)                      // номер ошибки
{ 
    int counter = 0;                        // счётчик
    bool chet = true;                       // флаг для поиска строки
    int k = 0;                              // счётчик
    int i = 0;                              // счётчик
    int j = 0;                              // счётчик

    for (i = 0; i < rN; i++)                // пока не дошли до последней строки
    {
        chet = true;                        // на каждой новой строке возвращаем флаг в исходное состояние
        for (j = 0; j < rM; j++)            // пока не дошли до последнего столбца
        {
            if (pmatr[i][j] % 2 == 0)       // если элемент строки чётный
            {
                chet = false;               // строка не подходит
            }// if
        }// for
        if (chet)                           // нашли строку из нечётных элементов         
        {
            k++;                            // увеличили счётчик таких строк
        }// if
    }// for
    if (k == 0)                             // нет таких строк
    {
        ErrNo = 10;           
    }// if
    return k;                               // вернули в caller наше нужное значение (количество искомых строк)
}// kol_vo

 /*-------------------------------------------------*/
 /*  поиск максимального элемента,   */
 /*  который встречается не один раз */
 /*----------------*/
int maxim(int pmatr[][M_Max]               // указатель на массив
        , int rN                           // реальное количество строк
        , int rM                           // реальное количество столбцов
        , int & ErrNo)                     // код ошибки
{
    int i = 0;                             // счётчик
    int a = 0;                             // для запоминания такого элемента
    int j = 0;                             // счётчик
    int k = 0;                             // счётчик
    int vector[M_Max *M_Max];                   // вектор-массив, созданный из элементов нашего многомерного
    cout << "\n\t\t Вектор-массив из элементов исходной матрицы:\n";
    for (i = 0; i < rN; i++)               // пока не дошли до последный строки
    {
        for (j = 0; j < rM; j++)           // пока не дошли до последнего столбца
        {
            //*(*(pmatr + i)+j))
            vector[k] = pmatr[i][j];       // помещаем на данное место элемент многомерного массива
            cout << vector[k]<<" ";        // контроль получившегося вектора
            k++;                           // переходим к следующему индексу (также узнаем реальную длину)
            
        }// for
    }// for

    cout << "\n\n\t\t Сортировка выбором. Отстортированный массив: \n";
    //вызов функции с ФАКТИЧЕСКИМИ параметрами
    sort(vector, k);                       // указатель для вектора, фактическое значение k, т.к мы его менять не будем                

 
    for (i = k - 1; i >= 0; i--)           // для всех элементов вектора, начиная с конца(для упрощения поиска максимального)
    {
        if (vector[i] == vector[i - 1])    // если данный равен предыдущему (есть повторение элемента)
        {
            a = vector[i];                 // запоминаем этот элемент
            break;                         // выходим - нет смысла продолжать
        }// if
    }// for
    if (a == 0)                            // все элементы различны(нет повторов)
    {

        ErrNo = 7;
        return 1;
    }// if
    
    cout << "\nМаксимальное из чисел, встречающихся в заданной матрице более одного раза: " << a << endl;
    return(0);                             // выходим без ошибки
}// maxim

 /*-------------------------------------------------*/
 /* сортировка вектора-массива выбором */
 /*--------------------*/
int sort(int* vector                       // указатель на вектор-массив
       , int mvlen)                        // длина вектора-массива
{
    int Min;                               // минимальный элемент
    int jMin;                              // индекс минимального элемента
    int iSort;                             // граница отсортированной области
    int i, j;                              // счётчики
    int Temp;                              // для перемещения

    for (iSort = 0; iSort < mvlen - 1; iSort++)   // пока не дошли до конца
    {
        // первый элемент из неупорядоченных назначаем минимальным
        Min = vector[iSort];                     // мимнимум
        jMin = iSort;                            // его индекс

        // ищем минимальный элемент в оставшейся части массива
        for (j = iSort + 1; j < mvlen; j++)
        {
            if (vector[j] < Min)                 // очередной кандидат на минимальный
            {
                // запоминаем минимальный элемент и его номер
                Min = vector[j];
                jMin = j;
            }// if

        }// for j

        // нашли минимум в неупорядоченной части массива
        // ставим его на место первого в неупорядоченной части массива
        // меняем элементы местами
        Temp = vector[iSort];
        vector[iSort] = vector[jMin];
        vector[jMin] = Temp;

        //cout << "\n/2: ";  // контрольная печать
        //for (int i = 0; i < mvlen; i++)
        //{
        //	cout << vector[i] << " ";
        //}//for i
        //		cout << "\n";

    }// for

    // ПЕЧАТЬ РЕЗУЛЬТАТА	
    for (i = 0; i < mvlen; i++)         // выводим массив после сортировки
    {
        cout << vector[i]<<" ";
    }// for i
    cout << endl << endl;;

    return(2);

}// sort

 /*-------------------------------------------------*/
 /* сообщения об ошибках */
 /*-----------------------*/

void PrintMessage(int xErrCode          //код ошибки
                , const char* FNAME)    //имя файла с ошибкой
{
    // расшифровка кода возврата в текст сообщения об ошибке
    switch (xErrCode)
    {
    case 1: cout << "/PrintMessage: Файл " << FNAME
        << " не найден;\n";
        break;
    case 2: cout << "Файл " << FNAME << " пустой;\n";
        break;
    case 3: cout << "В файле " << FNAME << " не число;\n";
        break;
    case 4: cout << "ОШИБКА!Среди элементов массива " << FNAME << " есть не число;\n";
        break;
    case 5: cout << "Вы ввели больше элементов в " << FNAME << ", чем вмещает массив;\n";
        break;
    case 6: cout << "Вы ввели меньше элементов в " << FNAME << ", чем указали;\n";
        break;
    case 7: cout << "В файле " << FNAME << " все элементы массива встречаются один раз;\n";
        break;
    case 8: cout << "В файле " << FNAME << " число строк матрицы отрицательно;\n";
        break;
    case 9: cout << "В файле " << FNAME << " число столбцов матрицы отрицательно;\n";
        break;
    case 10: cout << "В файле " << FNAME << " все строки содержат хотя бы один чётный элемент;\n";
        break;
    default:
        break;
    }// switch

    return;                               // возврат значения соответственно типу
}// PrintMessage